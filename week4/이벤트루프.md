출처: [우아테크-10분 테코톡] 피터의 이벤트 루프 [https://www.youtube.com/watch?v=wcxWlyps4Vg&list=RDCMUC-mOekGSesms0agFntnQang&index=1](https://www.youtube.com/watch?v=wcxWlyps4Vg&list=RDCMUC-mOekGSesms0agFntnQang&index=1)

이벤트 루프에 대해 얘기하기 전
먼저 짚고 넘어가야 할 개념이 여러 가지가 있다.
다음의 개념들에 대해 먼저 이해하고 중반쯤부터 이벤트루프에 대해 알아보자.

1. 콜백함수
2. 동기/비동기
3. 자바스크립트 엔진
4. 브라우저 구조

# 콜백 함수

특정 함수의 인자로 들어가는 함수이다.
비동기 콜백이냐 동기 콜백이냐에 따라 콜백 함수의 **실행 시점**이 달라진다.

## 동기 콜백

호출 즉시 실행

## 비동기 콜백

나중에 조건을 만족하면 실행

### 1) 이벤트 리스너 (addEventListener)

특정 이벤트 발생 시

### 2) 타이머 (setTimeout, setInterval)

일정 시간 경과 후

### 3) XMLHttpRequest 요청

async/await로 axios 요청 시

## 예시 코드

```jsx
console.log('배고프다');

setTimeout(function () {
  console.log('저기 어때?');
}, 2000);

console.log('저기 가 봤어?');
```

<br/>

### 동기적 예상

위에서부터 순서대로 실행

```jsx
// 배고프다

// (2초 후)
// 저기 어때?

// 저기 가 봤어?
```

### 비동기적 예상

코드를 순서대로 실행하다가

**setTimeout과 같은 비동기 함수**를 만나면

함수의 **콜백 함수를 자바스크립트의 뒤편(backstage)**으로 보내고

**타이머를 작동시킨다.**

그리고 나머지 동기 코드들이 실행된 후에

**타이머의 시간이 지나면 콜백 함수를 실행한다.**

```jsx
// 배고프다

// 저기 가 봤어?

// (2초 후)
// 저기 어때?
```

<br/>

# 자바스크립트 엔진

![](https://images.velog.io/images/yena1025/post/86338ceb-f644-462c-8100-b999458a9e66/engine.png)

## 자바스크립트 엔진

자바스크립트 엔진은 자바스크립트 코드를 해석하고 실행하는 ‘번역기’이다.

각 브라우저마다 엔진의 종류가 다르며 (예: 사파리는 Webkit, 크롬은 V8 등)

구성은 크게 힙(Heap)과 호출스택(Call Stack)으로 구분된다.
![](https://images.velog.io/images/yena1025/post/7f8a4813-47a1-4fa0-81b9-b424232803ae/js_engine.png)

### 힙

변수나 객체 등이 저장되는 일종의 '창고'같은 개념이다.

이번 포스트에서 크게 중요한 개념은 아니다.

### 호출 스택

호출되는 순서대로 함수가 쌓이고 제거되는 스택이다.

#### 호출 스택의 동작 과정

1. 자바스크립트 코드에서 함수의 실행이 시작되면 호출 스택에 해당 함수를 집어넣는다.

2. 함수의 실행이 끝나면 호출 스택의 맨 위에 있는 실행된 함수를 꺼내서 제거한다.

> 즉, 흔히 '호출 스택이 비어 있다'는 말은 '실행할 함수가 남아있지 않다'는 말이다.

## 예시 코드

아래 예시를 보기 전 어떤 장면을 상상해보자.
컵 모양의 호출스택이 있고 함수 실행이 시작되면
그 안에 함수를 블록처럼 쌓은 뒤,
실행이 끝나면 블록을 꺼내는 장면이다.

> 처음에 호출스택 가장 밑바닥에는 **Global context**가 먼저 쌓여 있다.
> 이는 '**전역 문맥**'을 의미하며, 전역 변수가 있는 곳이다.
> Global context은 호출스택의 밑바닥에 항상 존재하며,
> 호출스택 작업이 끝나면 맨 마지막에 사라진다.

```jsx
function second() {
  setTimeout(function () {
    console.log('세상에..');
  }, 2000);
}

function first() {
  console.log('디저트를 안 먹는다고?');
  second();
  console.log('어떻게 디저트를 안 먹을 수 있지?');
}

first();
```

### 실행 순서

(전역 문맥은 제외)

1. first 함수가 호출 스택에 쌓임
2. first 함수가 실행되면서 첫 번째 콘솔이 그 위에 쌓임
3. 첫 번째 콘솔이 출력된 후 제거됨
4. 이후 second 함수가 쌓이고
5. 그 안에 있는 setTimeout 함수가 쌓인 뒤 실행됨
6. setTimeout이 실행되면 콜백함수와 타이머를 자바스크립트 뒤편(**Web API**)으로 보냄
7. setTimeout의 실행이 끝나서 스택에서 제거됨
8. setTimeout밖에 없었던 second 함수도 제거됨(return)
9. first 함수의 남은 두 번째 콘솔이 쌓인 뒤 출력(실행)되고
10. 실행이 모두 끝난 first 함수도 리턴
11. **호출 스택이 비게 되면** 자바스크립트 뒤편에 있던 타이머 시간인 2초가 지나고 나서 Web API에 있던 콜백함수를 콜백 큐로 보냄
12. 이벤트 루프가 **호출 스택이 비어있는 것을 확인한 후** 콜백 큐의 콜백함수를 호출스택에 읏차 하고 넣음
13. 콜백 함수의 콘솔이 마저 출력된 뒤에 제거됨 (모든 과정 완료!)

> **콘솔결과**
> // 디저트를 안 먹는다고?
> // 어떻게 디저트를 안 먹을 수 있지?
> // (2초 뒤) 세상에..

<br/>

# 브라우저의 구조

자바스크립트는 ‘**싱글 스레드 언**어’이다.
이 말이 무슨 뜻이냐면
자바스크립트는 **호출 스택을 1개만 사용한다**는 뜻이다.

위에서 봤듯이 호출 스택은 '일을 처리하는 곳'이다.

즉, 호출 스택이 하나라는 말은
자바스크립트가 **한 번에 한 가지 일만 처리할 수 있다**는 뜻이다.

![](https://images.velog.io/images/yena1025/post/6ee8660f-b19f-4224-a97b-6b03e4912858/browser.png)

**자바스크립트 엔진**은 한 번에 한 가지 작업만 처리할 수 있는 **싱글 스레드**이지만,

**브라우저**는 자바스크립트 엔진 외에도

**Web API, 이벤트 루프, 콜백 큐** 등을 가지고 있는 **멀티 스레드**로 동작한다.

<br/>

**Web API**는 DOM 조작(addEventListener), AJAX(Fetch API), setTimeout과 같은

**비동기 메소드**들을 자바스크립트에 제공한다.

비동기 메소드는 실행이 되고 나면

인자로 받은 콜백함수를 Web API로 보낸 뒤 콜 스택에서 사라진다.

<br/>

## 이벤트 루프

![](https://images.velog.io/images/yena1025/post/27d330b9-fd3c-489b-8762-001e5ccaf3b7/eventloop.png)

이벤트 루프의 역할은 호출 스택과 콜백 큐를 계속 주시하고 있다가

다음의 2가지 조건이 만족되면

콜백 큐의 콜백 함수들을 순서대로 호출 스택에 넣는다.

### 조건![](https://images.velog.io/images/yena1025/post/660e2da5-837d-4b7c-9678-e3987f28d31b/eventloop.png)

1. 콜백 큐에 콜백함수가 들어 있다.

2. **호출 스택이 비어 있다.** (중요!)

   (▶ 반드시 호출 스택이 비어있어야 콜백 큐의 콜백함수가 호출 스택으로 이동 가능)

<br/>

## 비동기 에러상황

비동기 함수를 실행하다보면

try-catch가 에러를 제대로 잡지 못하는 경우가 생김

```
btn.addEventListener('click', function() { // (A)
  try {
    axios.get(url, function(res) { // (B)
      // 여기서 에러 발생
    });
  } catch (e) {
    console.log(e.message);
  }
});
```

위의 코드에서 (A)의 try-catch문이 (B)에서 발생하는 에러를 잡아내지 못함

### 왜?

1. 이벤트리스너에서 클릭 이벤트 발생
2. 콜백함수(try-catch문)인 (A)가 콜백 큐로 이동
3. **호출 스택이 비어있고,** **콜백 큐에 콜백 함수가 있으므로 **
   이벤트 루프가 콜백 큐의 (A) 콜백 함수를 호출 스택으로 보냄
4. (A) 함수의 try-catch문이 실행되면서 axios의 get 함수가 호출 스택에 쌓임
5. get 함수가 실행되면 url과 (B) 콜백 함수를 Web API에 보내고 자신은 return
6. try문 실행이 끝난 (A) 콜백 함수 리턴
7. Web API에 있던 url 정보로 HTTP 요청을 보내고 나면 (B) 콜백함수가 콜백 큐로 들어감
8. **호출 스택이 비어있고,** **콜백 큐에 콜백 함수가 있으므로**
   이벤트 루프가 콜백 큐의 (B) 콜백 함수를 호출 스택으로 보냄
9. (B) 콜백 함수가 실행 중 에러 발생.
   하지만 try-catch문이 있는 (A) 콜백 함수가 이미 리턴(호출 스택에서 제거)되었으므로 해당 에러를 감지하지 못함
   => 에러 처리가 되지 않음

### 해결방법?

(B) 콜백 함수에도 똑같이 try-catch문을 넣어주면 된다.
((B) 함수 자체 내에서 에러를 처리할 수 있도록)

## setTimeout의 타이머가 0초인 경우

대기 시간이 0초인 setTimeout 함수는

프론트엔드 환경의 자바스크립트 코드에서 종종 볼 수 있는 코드이다.

0초 후에 실행 = 즉시 실행? (X)

```jsx
console.log('피카츄!');

setTimeout(function () {
  console.log('삐까삐까!');
}, 0);

console.log('백만볼트!');
```

위의 내용을 잘 이해했다면 왜 '삐까삐까!'가 맨 마지막에 출력되는지 알 수 있다 😏
